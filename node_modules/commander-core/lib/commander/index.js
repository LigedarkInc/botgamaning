'use strict'

const path = require('path');
const fs = require('fs');

const glob = require('glob');
const { promisify } = require('util');

const { ConfigureError } = require('../utils');
const Command = require('./command');

const findFiles = promisify(glob);

class Commander {
	constructor() {
		this.commands = [];
		this.lastCheckDirectory = null;
	};

	async loadFromDirectory(dir) {
		const absPath = path.resolve(dir);
		const filePaths = await findFiles(`${absPath}/**/*.js`);

		for(const filePath of filePaths) {
			if(this.lastCheckDirectory) {
				delete require.cache[require.resolve(filePath)];
			}

			let file = require(filePath);

			if(Object.keys(file).length === 0) {
				continue;
			}
			if(!Array.isArray(file)) {
				file = [file]
			}

			for(const com of file) {
				if(!(com instanceof Command)) {
					throw new ConfigureError(`Экспартируемые данные в файле ${filePath} не являются командой`);
				}
				
				this.commands.push(com);
			}
		}

		this.commandsDir = absPath;
	};

	find(context) {
		let command;

		for(const com of this.commands) {
			if(com.pattern.test(context.command)) {
				command = com;
			}
		}

		if(!command) {
			return null;
		}

		context.body = context.command.match(command.pattern)

		if(command.commands.length) {
            command = command.findSubCommand(context);
		}

		return command;
	};

	//logger
	watchDirectory(logger) {
        fs.watch(this.commandsDir, { encoding: 'utf8', recursive: true  }, async (event) => {
            if (event === 'rename' || Date.now() - this.lastCheckDirectory < 200) {
                return;
            }

            logger.info('Перезагрузка команд...');

            this.commands = [];
            this.lastCheckDir = Date.now();
            await this.loadFromDirectory(this.commandsDir);
        });
    }
}

module.exports = Commander;
